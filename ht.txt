 Example Table Content to Paste
You can copy and paste this into your PowerPoint table directly:

Model	Accuracy (%)	Reason
Theta	96.96	Best for trend/seasonal series. Simple, accurate, low error.
ARIMA	96.91	Needs stationarity, less flexible to seasonality.
RandomForest	96.55	Not time-series native, lacks temporal correlation modeling.
SMA	96.54	Averages past, cannot predict future trend changes.
SVR	96.21	Needs tuning, weak in time context.
Holt	96.04	Good for trend, poor with seasonality.
LightGBM	95.76	Needs time-based features, not designed for sequence prediction.
Prophet	90.31	Works on assumptions; overfits/underfits in noisy data.
XGBoost	89.78	Powerful but lacks inherent time-series handling.
AutoARIMA	72.27	Automated, poor accuracy due to poor parameter choices.

‚úÖ Option 2: Paste Pre-made Table from Excel
Open Excel, paste the table data above into 3 columns.

Format it (bold headers, align cells).

Select the table ‚Üí Copy.

Go to PowerPoint ‚Üí Paste ‚Üí Use Destination Theme or Keep Formatting.

Resize and position the table as needed.

Let me know if you'd like a PowerPoint (.pptx) file generated or a screenshot of a styled table!









Ask ChatGPT
You said:
model justification for theta model why this is suitable . give factors and explain 


ChatGPT said:
Here's a clear and structured justification for why the Theta Model is particularly suitable for forecasting security metrics, broken down into key factors:

‚úÖ Why Theta Model is Suitable for Forecasting Security Metrics
1. üìà Handles Trend Effectively
Security metrics (like SLA adherence, patch rates, vulnerability closure %) often show gradual upward or downward trends over time.

Theta model decomposes time series and captures both long-term trends and local variations, making it ideal for such gradual patterns.

2. üìä Low Complexity, High Accuracy
Unlike models like XGBoost or Prophet that require extensive tuning and data preprocessing, Theta is simple yet powerful.

Your evaluation shows:

üîπ Lowest MAE (3.04)
üîπ Lowest RMSE (3.52)
üîπ Highest Accuracy (96.96%)
This shows it outperforms complex models without needing deep configurations.

3. üîÑ Robust to Noisy Business Data
Security metrics can have fluctuations due to policy, people, or system changes.

Theta is robust and does not overfit to such noise, unlike decision tree-based models or deep learning methods.

4. üß† No Assumptions Needed
Traditional models like ARIMA assume stationarity and require differencing and diagnostics.

Theta works well without requiring prior transformations, saving time and reducing chances of modeling errors.

5. üßÆ Works Well With Short Time Series
Often in security reporting, only limited historical data (12‚Äì36 months) is available.

Theta model is designed to work effectively even with smaller datasets compared to LSTM or Prophet.

6. ‚öñÔ∏è Balance Between Interpretability and Performance
Unlike black-box models (e.g., XGBoost or SVR), Theta‚Äôs forecasting logic is transparent and aligns with decision-maker expectations in enterprises (CISO, compliance).

‚úÖ Summary Table
Factor	Why Theta Wins
Trend Handling	Captures long-term and local variations
Accuracy	Best MAE, RMSE, and Accuracy among all tested models
Simplicity	No complex tuning or preprocessing needed
Noise Robustness	Performs well even with real-world data noise
Works on Small Data	Does not need hundreds of time steps
Interpretability	Easy to explain to non-technical stakeholders

Let me know if you'd like a PowerPoint slide, diagram, or comparison chart to visualize this!








You said:
history of theta model


ChatGPT said:
üìú History of the Theta Model
The Theta Model is a relatively recent but powerful time series forecasting method that gained attention for its simplicity and strong performance.

‚úÖ Key Historical Milestones
1. Origin & Proposal (2000)
Introduced by Assimakopoulos & Nikolopoulos in the year 2000.

Published in:
üìÑ "The Theta Model: A Decomposition Approach to Forecasting"
‚û§ International Journal of Forecasting

It was proposed as a decomposition-based forecasting model, which combines both linear trend extrapolation and local curvature adjustments of a time series.

2. Core Idea
The method modifies the second differences (acceleration) of the time series using a tuning parameter Œ∏ (theta).

It splits the original series into multiple theta lines, typically:

One line capturing the long-term trend

One line emphasizing short-term fluctuations

These are then forecasted separately and combined.

3. M3 Forecasting Competition (2000)
The Theta model gained significant recognition by achieving the best overall performance in the M3-Competition.

The M3 was one of the largest international time series forecasting competitions.

This put the model in the spotlight as a benchmark method for univariate forecasting.

4. Adoption & Enhancements
After M3, researchers adopted Theta as a baseline model due to its:

Simplicity

High performance

Ability to handle diverse types of time series

Variants and hybrid models (e.g., Theta-ARNN, Theta-LSTM) were later developed for improved performance in specific domains.

5. Integration into Forecasting Libraries
Today, Theta is implemented in major forecasting libraries like:

R's forecast package (thetaf() function)

Python‚Äôs statsmodels.tsa.forecasting.ThetaModel

Also available in Forecasting APIs and AutoML tools

‚úÖ Summary
Aspect	Details
Introduced By	Assimakopoulos & Nikolopoulos
Year	2000
Publication	International Journal of Forecasting
Competition Success	Best performer in M3 Forecasting Competition
Strength	Combines trend + curvature, handles wide range of series
Popularity	Widely adopted in academia and industry as a baseline model

Let me know if you'd like this history converted into a timeline graphic or slide content!








You said:
theta model in m3 competition.give in three bullet points


ChatGPT said:
Here are three concise bullet points about the Theta Model in the M3 competition:

‚úÖ Top Performer: The Theta model achieved the best overall forecasting accuracy among all competing methods in the M3 Forecasting Competition (2000), which evaluated over 3,000 real-world time series.

üìä Robust Across Domains: It outperformed other models across multiple forecast horizons and diverse domains (finance, economics, industry), proving its versatility.

üß† Recognition as a Benchmark: After its success in M3, Theta became a standard benchmark model in time series forecasting research and practice.








You said:
what are the limitation of this project ?give in bullet pointd


ChatGPT said:
Here are the limitations of your security metric forecasting project using time series models like Theta:

‚ö†Ô∏è Limitations
üìâ Assumes Historical Patterns Continue
Forecasting relies heavily on past trends, which may not reflect sudden changes due to cyber attacks, policy shifts, or organizational restructuring.

üìä Limited to Univariate Time Series
Models like Theta forecast one metric at a time and do not account for external factors (e.g., new vulnerabilities, threat intelligence feeds).

üß™ Lack of Real-Time Updates
The model uses batch-mode historical data, so it may not reflect current or emerging security risks in real time.

‚ùå No Anomaly Root Cause Analysis
While it can flag anomalies or low-performing metrics, it doesn‚Äôt explain why something is underperforming.

üß† Not Adaptive Without Retraining
If new data patterns emerge, the model needs manual retraining‚Äîit cannot adjust dynamically like some online learning models.

üõ†Ô∏è Thresholds Are Manually Defined
RAG status depends on fixed thresholds (e.g., >=80%), which may not generalize well across different metrics or business units.

üßæ Interpretability for Non-Tech Users
Despite its simplicity, the statistical nature of forecasting may not be easily understood by non-technical security teams or executives.

üìÅ Data Quality Dependency
Accuracy drops if the historical data is missing, noisy, inconsistent, or sparsely populated for certain metrics.

Let me know if you'd like these turned into a PowerPoint slide or a table format.








You said:
future scope of this project


ChatGPT said:
Here‚Äôs the future scope of your security metric forecasting project, clearly laid out in bullet points:

üöÄ Future Scope
ü§ñ Multi-Model Forecasting Support
Integrate additional models (e.g., LSTM, Prophet, AutoML) and dynamically select the best-performing one per metric.

üîó Incorporate External Factors
Enhance forecasting by including external variables like threat feeds, policy changes, or IT deployments for more contextual predictions.

üìä Dashboard Automation
Build an interactive BI dashboard (using Streamlit, Power BI, or Grafana) to monitor metric forecasts, trends, and anomaly alerts in real time.

üß† Self-Learning Models
Implement online learning or reinforcement learning to allow the system to adapt automatically as new data is ingested.

üì• Real-Time Data Ingestion
Connect to live SIEM logs, vulnerability scanners, and patch management systems for real-time metric updates and forecasts.

üóÇÔ∏è Forecast Across Aggregation Levels
Enable forecasting not just by metric name but also by region, business unit, application, or team, for granular insights.

üö¶ Smart RAG Threshold Learning
Replace static thresholds with adaptive, ML-derived thresholds that evolve over time and context.

üîê Risk Prioritization Engine
Add logic to rank risks based on forecasted drops in performance, aiding in prioritization of cybersecurity tasks.

üßæ Alerting & Notification System
Integrate with email, Slack, or ticketing systems to alert stakeholders when a forecast crosses critical thresholds.

Would you like this formatted as a PowerPoint slide or included in a presentation document?

Model	Accuracy (%)	Remarks / Reason for Lower Suitability
Theta	96.96	Best performance overall; excels in short-term seasonal and trend forecasts; simple yet highly accurate.
ARIMA	96.91	Performs well but less flexible with non-linear patterns; requires stationarity assumptions.
RandomForest	96.55	Good general model, but not designed for time-series; doesn‚Äôt naturally capture time dependencies.
SMA	96.54	Simple moving average lacks predictive power for future trends or seasonality.
SVR	96.21	Handles non-linearities but struggles with temporal autocorrelation; needs careful tuning.
Holt	96.04	Good for trends, but lacks robustness for seasonality or non-linear patterns.
LightGBM	95.76	Tree-based models aren‚Äôt ideal for continuous, sequential time data; needs feature engineering.
Prophet	90.31	Designed for business time-series, but may overfit or underfit depending on noise and frequency.
XGBoost	89.78	Like LightGBM, not naturally sequential; great for tabular data, but not optimized for forecasting.
AutoARIMA	72.27	Fully automated but performs poorly due to lack of tuning or data assumptions; may misidentify optimal parameters.




Model	Accuracy (%)	Short Reason (for short, irregular, no-trend data)
Theta	96.96	Performs well on irregular, short data without strong trend/seasonality.
ARIMA	96.91	Needs consistent trend or stationarity‚Äîpoor fit for noisy, irregular metrics.
RandomForest	96.55	Lacks time-awareness; not ideal for sequence prediction in security data.
SMA	96.54	Too basic; fails on unpredictable or noisy data.
SVR	96.21	Struggles with time dependencies; sensitive to irregular patterns.
Holt	96.04	Needs trend; underperforms when data is flat or noisy.
LightGBM	95.76	Requires engineered features; weak with raw, short time series.
Prophet	90.31	Designed for trend/seasonality; fails on short, irregular metrics.
XGBoost	89.78	Not time-aware; doesn‚Äôt suit sparse or unstable time data.
AutoARIMA	72.27	Fails to auto-tune correctly on short, non-stationary security metrics.


To **add a model selection dropdown** in your Streamlit dashboard and dynamically run forecasting based on the selected model (e.g., Theta, ARIMA, Prophet, etc.), you can follow this integration plan:

---

## ‚úÖ **Steps to Add Model Selection in Streamlit Dashboard**

### üîß Step 1: Add a model selector

Add this below your existing dropdowns:

```python
model_choice = st.selectbox("Select Forecasting Model", [
    "Theta", "ARIMA", "Holt", "Prophet", "SMA", 
    "RandomForest", "LinearRegression", "SVR", "LightGBM", "XGBoost"
])
```

---

### ‚öôÔ∏è Step 2: Replace `ThetaModel` forecasting block with conditional logic

Replace this:

```python
model = ThetaModel(train, period=1)
fit_model = model.fit()
forecast = fit_model.forecast(steps=steps)
```

With this:

```python
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from statsmodels.tsa.arima.model import ARIMA
from prophet import Prophet
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from lightgbm import LGBMRegressor
from xgboost import XGBRegressor

# Prepare forecasting
forecast = None

try:
    if model_choice == "Theta":
        model = ThetaModel(train, period=1)
        fit_model = model.fit()
        forecast = fit_model.forecast(steps=steps)

    elif model_choice == "ARIMA":
        model = ARIMA(train, order=(2, 2, 2))
        fit_model = model.fit()
        forecast = fit_model.forecast(steps=steps)

    elif model_choice == "Holt":
        model = ExponentialSmoothing(train, trend='add')
        fit_model = model.fit()
        forecast = fit_model.forecast(steps=steps)

    elif model_choice == "Prophet":
        df_prophet = train.reset_index().rename(columns={'ReportingDate': 'ds', 'MetricValue': 'y'})
        prophet = Prophet()
        prophet.fit(df_prophet)
        future = prophet.make_future_dataframe(periods=steps, freq='MS')
        forecast = prophet.predict(future).iloc[-steps:]['yhat'].values

    elif model_choice == "SMA":
        sma_value = train.rolling(window=3).mean().iloc[-1]
        forecast = [sma_value] * steps

    elif model_choice in ["RandomForest", "LinearRegression", "SVR", "LightGBM", "XGBoost"]:
        df_reset = df.reset_index()
        df_reset['month'] = df_reset['ReportingDate'].dt.month
        df_reset['year'] = df_reset['ReportingDate'].dt.year
        df_reset['t'] = np.arange(len(df_reset))

        X = df_reset[['month', 'year', 't']].values
        y = df_reset['MetricValue'].values
        X_train = X
        y_train = y

        last_t = X_train[-1][2]
        future_t = np.arange(last_t + 1, last_t + 1 + steps)
        future_months = [(df.index[-1] + relativedelta(months=i+1)).month for i in range(steps)]
        future_years = [(df.index[-1] + relativedelta(months=i+1)).year for i in range(steps)]
        X_future = np.column_stack([future_months, future_years, future_t])

        model_map = {
            "RandomForest": RandomForestRegressor(),
            "LinearRegression": LinearRegression(),
            "SVR": SVR(),
            "LightGBM": LGBMRegressor(),
            "XGBoost": XGBRegressor()
        }

        model = model_map[model_choice]
        model.fit(X_train, y_train)
        forecast = model.predict(X_future)

    forecast = np.clip(forecast, 0, 100)

except Exception as e:
    st.error(f"Forecasting failed for model {model_choice}: {str(e)}")
    st.stop()
```

---

### ‚úÖ Benefits

* Dynamic switching between models
* Easy benchmarking
* Can plug in model evaluation metrics later (e.g., RMSE, MAPE)

---

Let me know if you want:

* üìâ Add accuracy evaluation (`MAE`, `RMSE`, etc.)
* üíΩ Downloadable forecast CSV
* üì¶ Sidebar filters or caching improvements

Want me to generate the **full merged final code** too?

elif model_choice == "AutoARIMA":
    model = pm.auto_arima(train, seasonal=False, stepwise=True, suppress_warnings=True)
    forecast = model.predict(n_periods=steps)

import pmdarima as pm

 f"""Extract the following from the sentence:
- metric_name
- level
- view

Sentence: "{sentence}"

Give output as:
metric_name: ...
level: ...
view: ...
If not found, say N/A."""

   prompt = f"""
Extract the following from the sentence below:
1. metric_name
2. level
3. view

Sentence: "{sentence}"

Give the answer in exactly this format:
metric_name: <value>
level: <value>
view: <value>

If a value is not present, write N/A.
""
pip install llama-cpp-python --config-settings="--cmake.define=GIT_EXECUTABLE=C:/Program Files/Git/cmd/git.exe"

pip install llama-cpp-python --config-settings "cmake.define.GIT_EXECUTABLE=C:/Program Files/Git/cmd/git.exe"

pip install llama-cpp-python   --extra-index-url https://abetlen.github.io/llama-cpp-python/whl/cpu


Here are **two SMART objectives** ‚Äî one for the **forecasting module** and one for the **chatbot integration** ‚Äî written in a structured format with clear success measures and evaluation methods:

---

### ‚úÖ **Objective 1: Forecasting Module Development**

* **Objective:**
  Build an accurate forecasting system for security metrics using multiple time series models.

* **SMART Measures of Success:**

  * **Specific:** Develop a forecasting pipeline supporting 10+ models (e.g., Theta, ARIMA, LGBM).
  * **Measurable:** Achieve at least **95% forecasting accuracy** (measured via MAPE).
  * **Achievable:** Use cleaned and transformed SQL-based metrics dataset for model training.
  * **Relevant:** Forecasting is essential for proactive security posture evaluation.
  * **Time-bound:** Complete and deploy forecasting module into dashboard by **Week 6**.
  * **Evaluation Method:**

    * Use test/train splits on historical data.
    * Evaluate MAE, RMSE, MAPE for each model.
    * Compare performance via Streamlit dashboard selection and reports.

---

### ‚úÖ **Objective 2: Intelligent Chatbot Integration**

* **Objective:**
  Enable users to query and retrieve metric forecasts conversationally through a voice-enabled AI chatbot.

* **SMART Measures of Success:**

  * **Specific:** Integrate speech-to-text, keyword extraction (NLP), and forecasting triggers into chatbot.
  * **Measurable:** Ensure chatbot correctly answers at least **90% of structured user queries**.
  * **Achievable:** Use `speech_recognition`, `Spacy`, and existing forecasting API/backend logic.
  * **Relevant:** Reduces manual navigation and makes metric analysis interactive and accessible.
  * **Time-bound:** Complete integration and deploy functional chatbot by **Week 7**.
  * **Evaluation Method:**

    * Test chatbot on a suite of 15 predefined prompts.
    * Measure success rate of valid entity extraction and correct forecasting output.
    * Collect peer/mentor feedback on usability.

---

Let me know if you need these rephrased for a form or slide!


Here‚Äôs a comprehensive response based on your internship experience, structured under the categories Barclays typically evaluates for intern reviews. Each section highlights your learning, growth, and contribution, followed by an overall comment.

---

### üíº **Business Skills (Understanding the Role & Project Objectives)**

During this internship, I developed a strong understanding of how security metric forecasting contributes to operational resilience and strategic decision-making. By aligning my work with business priorities, such as enhancing visibility into cyber risk trends, I ensured that my technical outputs were meaningful and actionable in a real-world enterprise setting.

---

### ü§ù **Presence and Communication (Team Interaction & Collaboration)**

I regularly engaged with my mentor and team to clarify requirements and validate my project roadmap. I maintained open communication through weekly updates and actively sought feedback, which helped me stay aligned with expectations. This fostered a collaborative environment and taught me the importance of stakeholder communication in agile project delivery.

---

### üß† **Values and Mindset (RISES + Empower, Challenge, Drive)**

I embodied Barclays‚Äô values by staying committed to quality (Stewardship), respecting timelines and feedback (Respect), and continuously learning (Excellence). I empowered myself to try advanced forecasting models, challenged assumptions about data suitability, and drove progress independently‚Äîespecially while integrating NLP into the chatbot under minimal supervision.

---

### ‚ö†Ô∏è **Risk and Controls (Understanding Challenges in Project)**

Security metrics are often irregular and noisy, which posed challenges in applying traditional forecasting models. I learned to manage these risks by carefully selecting appropriate models like Theta, validating assumptions, and adding anomaly detection. These controls improved model reliability and ensured forecasts didn't mislead stakeholders.

---

### üéØ **Role-Specific Objective (What I Did in My Project)**

I led the end-to-end development of a forecasting dashboard for security metrics and integrated it with a voice-enabled chatbot. I designed and tested multiple models, developed anomaly detection, and built user interfaces in Streamlit. My work provides automation and insights for better metric monitoring and decision-making.

---

### üìù **Overall Comment**

This internship helped me grow both technically and professionally. I improved my forecasting, NLP, and full-stack development skills while learning how to map technical solutions to business needs. I gained confidence in presenting my work, managing ambiguity, and adapting to enterprise environments. I am grateful for this opportunity to contribute meaningfully to the team.

---

Let me know if you'd like this converted into a format suitable for direct form input or PDF.


Objective 1: Forecasting Module Development
Objective:
Build an accurate forecasting system for security metrics using multiple time series models.

SMART Measures of Success:

Specific: Develop a forecasting pipeline supporting 10+ models (e.g., Theta, ARIMA, LGBM).

Measurable: Achieve at least 95% forecasting accuracy (measured via MAPE).

Achievable: Use cleaned and transformed SQL-based metrics dataset for model training.

Relevant: Forecasting is essential for proactive security posture evaluation.

Time-bound: Complete and deploy forecasting module into dashboard by Week 6.

Evaluation Method:

Use test/train splits on historical data.

Evaluate MAE, RMSE, MAPE for each model.

Compare performance via Streamlit dashboard selection and reports.

Objective 2: Intelligent Chatbot Integration
Objective:
Enable users to query and retrieve metric forecasts conversationally through a voice-enabled AI chatbot.

SMART Measures of Success:

Specific: Integrate speech-to-text, keyword extraction (NLP), and forecasting triggers into chatbot.

Measurable: Ensure chatbot correctly answers at least 90% of structured user queries.

Achievable: Use speech_recognition, Spacy, and existing forecasting API/backend logic.

Relevant: Reduces manual navigation and makes metric analysis interactive and accessible.

Time-bound: Complete integration and deploy functional chatbot by Week 7.

Evaluation Method:

Test chatbot on a suite of 15 predefined prompts.

Measure success rate of valid entity extraction and correct forecasting output.

Collect peer/mentor feedback on usability.

Here is the **expanded and enriched version** of both SMART objectives, adding further detail to each point (in total \~20‚Äì30 extra words per bullet) to make it suitable for **official evaluation forms, reports, or slide decks**:

---

### **Objective 1: Forecasting Module Development**

**Objective:**
Design, develop, and deploy a robust forecasting engine that predicts future values of critical security metrics using a range of statistical and machine learning time series models. This will support proactive decision-making and operational resilience.

**SMART Measures of Success:**

* **Specific:**
  Create a flexible and modular forecasting pipeline capable of running over 10 time series models (Theta, ARIMA, LGBM, Prophet, etc.) to enable comparative performance analysis for different metric types.

* **Measurable:**
  The models must achieve at least **95% average accuracy** on historical data, as measured through MAPE. Evaluation will include over 30 distinct metrics across multiple levels and views from the security database.

* **Achievable:**
  Source, clean, and transform metric data from SQL Server tables. Apply feature engineering, normalization, missing data handling, and timestamp parsing to ensure quality inputs for model training and forecasting.

* **Relevant:**
  Forecasting is vital for identifying potential security performance degradations in advance. This predictive visibility will help decision-makers take preemptive actions before thresholds are breached.

* **Time-bound:**
  The full module (data ingestion, modeling, visualization, and DB integration) should be developed and deployed into the Streamlit dashboard by **Week 6**, with two rounds of testing and mentor feedback.

**Evaluation Method:**

* Split the dataset into training and test sets (e.g., 80:20) and evaluate each model using MAE, RMSE, and MAPE.

* Track and compare each model‚Äôs performance in a tabular format within the dashboard, supported by visual forecast plots and anomaly markers.

* Conduct reviews with mentors/peers after deployment to validate if the forecasts align with known patterns and expectations.

---

### **Objective 2: Intelligent Chatbot Integration**

**Objective:**
Develop and integrate an intelligent, voice-activated chatbot that enables users to conversationally request and retrieve forecasts for specific security metrics, enhancing accessibility and reducing dashboard complexity.

**SMART Measures of Success:**

* **Specific:**
  Implement an NLP-driven chatbot that combines speech recognition, text preprocessing, and entity extraction (using `Spacy`) to dynamically trigger forecast generation and display metric results on user command.

* **Measurable:**
  The chatbot must achieve at least **90% prompt understanding accuracy** across a test set of 15+ predefined prompts and handle at least 3 input variations per prompt.

* **Achievable:**
  Use available Python tools (`speech_recognition`, `Spacy`, Streamlit components) and integrate directly with the forecasting backend to reuse the logic and provide consistent results in real-time.

* **Relevant:**
  This solution minimizes manual dropdown selection and navigation, allowing users ‚Äî especially leadership or non-technical roles ‚Äî to interact with the platform quickly and intuitively through voice commands.

* **Time-bound:**
  Completion and deployment of the voice-enabled chatbot should occur by **Week 7**, followed by one week of improvement iterations based on testing feedback and enhancements for stability.

**Evaluation Method:**

* Validate chatbot accuracy using structured prompt testing and verify output correctness against expected forecasts from the dashboard logic.

* Use usability testing with peers or mentors to assess interaction quality, error handling, latency, and clarity of feedback.

* Track response accuracy, bug reports, and interaction metrics in logs and summarize findings for final evaluation.

---

Would you also like:

* A **PowerPoint-friendly table** layout of this content?
* Or **roles and responsibilities mapping** (e.g., Data Engineer for Objective 1, AI Engineer for Objective 2)?
import streamlit as st
from gtts import gTTS
import tempfile
import os
import speech_recognition as sr
import uuid
import win32com.client
from win32com.client import constants
import pythoncom
import re
from ctransformers import AutoModelForCausalLM
from statsmodels.tsa.forecasting.theta import ThetaModel
import pyodbc
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
import pandas as pd
import numpy as np
import calendar
import warnings
warnings.filterwarnings("ignore")

# Database connection
conn = pyodbc.connect(
    "DRIVER={ODBC Driver 17 for SQL Server};"
    "SERVER=GBRDSMSQ5000035\\FUS_SQLVIRT_Dev;"
    "DATABASE=FUSION_MI_DEV;"
    "Trusted_Connection=yes;"
)

cursor = conn.cursor()

class MetricDataProcessor:
    def __init__(self):
        self.current_date = datetime.now()
        
    def _parse_month_year(self, text: str) -> Optional[str]:
        month_map = {m.lower(): i for i, m in enumerate(calendar.month_abbr) if m}
        month_map.update({m.lower(): i for i, m in enumerate(calendar.month_name) if m}
        patterns = [
            r"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s*'?(\d{2,4})",
            r"(\d{1,2})[/-](\d{2,4})",
            r"(\d{4})[/-](\d{1,2})"
        ]
        for pattern in patterns:
            match = re.search(pattern, text.lower())
            if match:
                g = match.groups()
                if len(g) == 2:
                    if g[0] in month_map:
                        month, year = month_map[g[0]], int(g[1])
                    elif g[0].isdigit() and int(g[0]) in range(1, 13):
                        month, year = int(g[0]), int(g[1])
                    elif g[1].isdigit() and int(g[1]) in range(1, 13):
                        month, year = int(g[1]), int(g[0])
                    else:
                        continue
                    if year < 100:
                        year += 2000
                    return f"01/{month:02d}/{year}"
        return None

    def _extract_from_prompt(self, prompt: str, field: str, options: List[str]) -> Optional[str]:
        for opt in options:
            if re.search(rf"\b{re.escape(opt.lower())}\b", prompt.lower()):
                return opt
        return None

    def extract_metric_info(self, prompt: str) -> Optional[Dict[str, Union[str, int, bool]]]:
        # First get all unique metrics, levels and views from database
        query = "SELECT DISTINCT MetricName, ReportingLevel, ReportinView FROM metricpredictmodel"
        metadata = pd.read_sql(query, conn)
        
        result = {
            "metric": None, "level": None, "view": None,
            "date": None, "is_future": False,
            "last_n_months": None, "next_n_months": None
        }

        prompt_lower = prompt.lower()
        last_n = re.search(r"last\s*(\d+)\s*months?", prompt_lower)
        next_n = re.search(r"next\s*(\d+)\s*months?", prompt_lower)

        if last_n:
            result["last_n_months"] = int(last_n.group(1))
        elif next_n:
            result["next_n_months"] = int(next_n.group(1))
            result["is_future"] = True
        else:
            result["date"] = self._parse_month_year(prompt_lower)
            if result["date"]:
                dt = datetime.strptime(result["date"], "%d/%m/%Y")
                if dt > self.current_date:
                    result["is_future"] = True

        metric_names = metadata['MetricName'].unique()
        result["metric"] = self._extract_from_prompt(prompt_lower, "metric_name", metric_names)

        result["level"] = self._extract_from_prompt(prompt_lower, "level", metadata['LevelName'].unique())
        result["view"] = self._extract_from_prompt(prompt_lower, "view", metadata['ViewName'].unique())

        if result["metric"] and (result["level"] is None or result["view"] is None):
            mdata = metadata[metadata['MetricName'] == result["metric"]]
            if not mdata.empty:
                if result["level"] is None:
                    result["level"] = mdata.iloc[0]["LevelName"]
                if result["view"] is None:
                    result["view"] = mdata.iloc[0]["ViewName"]

        if not result["metric"] or not result["level"] or not result["view"]:
            return None
        if not result["last_n_months"] and not result["date"] and not result["next_n_months"]:
            return None
        return result

    def _get_historical_data(self, metric: str, level: str, view: str) -> pd.DataFrame:
        query = """
            SELECT ReportingDate, MetricValue 
            FROM metricpredictmodel 
            WHERE MetricValue is not null 
            AND MetricName=? AND ReportinView=? AND ReportingLevel=?
        """
        df = pd.read_sql(query, conn, params=[metric, level, view])
        if df.empty:
            return df
        df['ReportingDate'] = pd.to_datetime(df['ReportingDate'])
        df['MetricValue'] = df['MetricValue'].str.replace(r'%', '', regex=False).astype(float)
        df.dropna(inplace=True)
        df = df.sort_values('ReportingDate')
        df = df.rename(columns={'ReportingDate': 'date', 'MetricValue': 'value'})
        return df

    def _forecast_with_theta(self, historical: pd.DataFrame, forecast_date: Optional[str], steps: Optional[int] = None) -> Dict:
        try:
            ts = historical.set_index("date")["value"]
            model = ThetaModel(ts)
            res = model.fit()
            last_date = ts.index[-1]
            if steps is None:
                target = datetime.strptime(forecast_date, "%d/%m/%Y")
                steps = (target.year - last_date.year) * 12 + target.month - last_date.month
                if steps <= 0:
                    return {"value": "PREDICTION_ERROR", "error": "Target date must be in future"}
            forecast = res.forecast(steps=steps)
            forecast = np.clip(forecast, 0, 100)
            if forecast_date:
                return {
                    "value": round(forecast.iloc[-1], 2),
                    "model_params": str(res.params),
                    "last_historical_date": last_date.strftime("%d/%m/%Y"),
                    "last_historical_value": ts.iloc[-1]
                }
            return {
                "values": [round(v, 2) for v in forecast],
                "model_params": str(res.params),
                "last_historical_date": last_date.strftime("%d/%m/%Y"),
                "last_historical_value": ts.iloc[-1]
            }
        except Exception as e:
            return {"value": "PREDICTION_ERROR", "error": str(e)}

    def get_metric_data(self, info: Dict) -> pd.DataFrame:
        historical = self._get_historical_data(info["metric"], info["level"], info["view"])
        if historical.empty:
            return pd.DataFrame({"error": ["No historical data found."]})

        if info["last_n_months"]:
            start = self.current_date - timedelta(days=30 * info["last_n_months"])
            result = historical[(historical["date"] >= start) & (historical["date"] <= self.current_date)]
            return result[["date", "value"]]

        if info["is_future"] and info["next_n_months"]:
            forecast = self._forecast_with_theta(historical, None, steps=info["next_n_months"])
            base_date = self.current_date + timedelta(days=30)
            result = []
            for i, val in enumerate(forecast["values"]):
                date = (base_date + timedelta(days=30 * i)).replace(day=1)
                result.append({
                    "date": date.strftime("%d/%m/%Y"),
                    "value": val,
                    "model_params": forecast.get("model_params", ""),
                    "last_historical_date": forecast.get("last_historical_date", ""),
                    "last_historical_value": forecast.get("last_historical_value", "")
                })
            return pd.DataFrame(result)

        if info["is_future"] and info["date"]:
            forecast = self._forecast_with_theta(historical, info["date"])
            return pd.DataFrame([{
                "date": info["date"],
                "value": forecast["value"],
                "model_params": forecast.get("model_params", ""),
                "last_historical_date": forecast.get("last_historical_date", ""),
                "last_historical_value": forecast.get("last_historical_value", "")
            }])

        date_obj = datetime.strptime(info["date"], "%d/%m/%Y")
        result = historical[historical["date"] == date_obj]
        return result[["date", "value"]]

def save_speech_to_wav(text, filename):
    pythoncom.CoInitialize()
    speaker = win32com.client.Dispatch("SAPI.SpVoice")
    stream = win32com.client.Dispatch("SAPI.SpFileStream")
    stream.Open(filename, 3)
    speaker.AudioOutputStream = stream
    speaker.Speak(text)
    stream.Close()

model = AutoModelForCausalLM.from_pretrained(
    "llm1/tinyllama-1.1b-chat-v1.0.Q6_K.gguf",
    model_type="llama"
)

# Initialize Streamlit app
st.title("AI Assistant")

if "messages" not in st.session_state:
    st.session_state.messages = []

for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

processor = MetricDataProcessor()

input_text = st.chat_input("What's up?")
if input_text:
    with st.chat_message("user"):
        st.markdown(input_text)
    st.session_state.messages.append({"role": "user", "content": input_text})
    
    # First try to extract metric information
    extracted = processor.extract_metric_info(input_text)
    
    if extracted:
        df = processor.get_metric_data(extracted)
        if "error" in df.columns:
            response = df["error"].iloc[0]
        else:
            if extracted.get("next_n_months") or (extracted.get("date") and extracted["is_future"]):
                response = "<br>".join(
                    f"{row['date']}: {row['value']}%"
                    for _, row in df.iterrows()
                )
            else:
                response = "<br>".join(
                    f"{row['date'].strftime('%d/%m/%Y')}: {row['value']}%"
                    for _, row in df.iterrows()
                )
    else:
        # If no metric info found, use the LLM
        prompt = f"""Q: answer shortly (max limit 25 words). you are an AI assistant called bob. your work is to answer.\n\nQ: {input_text}\nA:"""
        response = model(prompt)
        response = response.strip()

    # Generate speech and display response
    temp_filename = os.path.join(tempfile.gettempdir(), f"{uuid.uuid4()}.wav")
    save_speech_to_wav(response, temp_filename)
    
    with st.chat_message("assistant"):
        st.markdown(response, unsafe_allow_html=True)
        st.audio(temp_filename, format="audio/wav")
    st.session_state.messages.append({"role": "assistant", "content": f"{response}"})

if st.button("Start recording"):
    r = sr.Recognizer()
    with sr.Microphone() as source:
        st.write("Speak now...")
        audio_data = r.listen(source)
    try:
        input_text = r.recognize_google(audio_data)
        if input_text:
            with st.chat_message("user"):
                st.markdown(input_text)
            st.session_state.messages.append({"role": "user", "content": input_text})
            
            # Process the voice input the same way as text input
            extracted = processor.extract_metric_info(input_text)
            
            if extracted:
                df = processor.get_metric_data(extracted)
                if "error" in df.columns:
                    response = df["error"].iloc[0]
                else:
                    if extracted.get("next_n_months") or (extracted.get("date") and extracted["is_future"]):
                        response = "<br>".join(
                            f"{row['date']}: {row['value']}%"
                            for _, row in df.iterrows()
                        )
                    else:
                        response = "<br>".join(
                            f"{row['date'].strftime('%d/%m/%Y')}: {row['value']}%"
                            for _, row in df.iterrows()
                        )
            else:
                prompt = f"""Q: answer shortly (max limit 25 words). you are an AI assistant called bob. your work is to answer.\n\nQ: {input_text}\nA:"""
                response = model(prompt)
                response = response.strip()
            
            temp_filename = os.path.join(tempfile.gettempdir(), f"{uuid.uuid4()}.wav")
            save_speech_to_wav(response, temp_filename)
            
            with st.chat_message("assistant"):
                st.markdown(response, unsafe_allow_html=True)
                st.audio(temp_filename, format="audio/wav")
            st.session_state.messages.append({"role": "assistant", "content": response})
            
    except sr.UnknownValueError:
        st.write("Sorry, could not understand")
    except sr.RequestError as e:
        st.write(f"Could not request results; {e}")


import pandas as pd
from datetime import datetime, timedelta
import random
import re
from typing import Optional, Dict, Union, List
import calendar
from statsmodels.tsa.forecasting.theta import ThetaModel
import warnings
import pyodbc
warnings.filterwarnings("ignore")

class MetricDataProcessor:
    def __init__(self):
        # Initialize database connection
        self.conn = pyodbc.connect(
            "DRIVER={ODBC Driver 17 for SQL Server};"
            "SERVER=GBRDSMSQ5000035\\FUS_SQLVIRT_Dev;"
            "DATABASE=FUSION_MI_DEV;"
            "Trusted_Connection=yes;"
        )
        
        # Fetch distinct metrics metadata from database
        self.metrics_metadata = self._fetch_metrics_metadata()
        self.time_series_data = self._fetch_time_series_data()
        self.current_date = datetime(2025, 5, 1)

    def _fetch_metrics_metadata(self) -> pd.DataFrame:
        """Fetch distinct metric names, levels, and views from database"""
        query = """
        SELECT DISTINCT 
            MetricName as metric_name,
            ReportingLevel as level,
            ReportingView as view
        FROM metricpredictmodel
        WHERE MetricName IS NOT NULL 
          AND ReportingLevel IS NOT NULL 
          AND ReportingView IS NOT NULL
        """
        return pd.read_sql(query, self.conn)

    def _fetch_time_series_data(self) -> pd.DataFrame:
        """Fetch time series data from database"""
        query = """
        SELECT 
            MetricName as metric_name,
            ReportingLevel as level,
            ReportingView as view,
            ReportingDate as date,
            MetricValue as value
        FROM metricpredictmodel
        WHERE MetricValue IS NOT NULL
        """
        df = pd.read_sql(query, self.conn)
        df['date'] = pd.to_datetime(df['date'])
        return df

    def _parse_month_year(self, text: str) -> Optional[str]:
        month_map = {m.lower(): i for i, m in enumerate(calendar.month_abbr) if m}
        month_map.update({m.lower(): i for i, m in enumerate(calendar.month_name) if m})
        patterns = [
            r"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s*'?(\d{2,4})",
            r"(\d{1,2})[/-](\d{2,4})",
            r"(\d{4})[/-](\d{1,2})"
        ]
        for pattern in patterns:
            match = re.search(pattern, text.lower())
            if match:
                g = match.groups()
                if len(g) == 2:
                    if g[0] in month_map:
                        month, year = month_map[g[0]], int(g[1])
                    elif g[0].isdigit() and int(g[0]) in range(1, 13):
                        month, year = int(g[0]), int(g[1])
                    elif g[1].isdigit() and int(g[1]) in range(1, 13):
                        month, year = int(g[1]), int(g[0])
                    else:
                        continue
                    if year < 100:
                        year += 2000
                    return f"01/{month:02d}/{year}"
        return None

    def _extract_from_prompt(self, prompt: str, field: str, options: List[str]) -> Optional[str]:
        for opt in options:
            if re.search(rf"\b{re.escape(opt.lower())}\b", prompt):
                return opt
        return None

    def extract_metric_info(self, prompt: str) -> Optional[Dict[str, Union[str, int, bool]]]:
        result = {
            "metric": None, "level": None, "view": None,
            "date": None, "is_future": False,
            "last_n_months": None, "next_n_months": None
        }

        prompt_lower = prompt.lower()
        last_n = re.search(r"last\s*(\d+)\s*months?", prompt_lower)
        next_n = re.search(r"next\s*(\d+)\s*months?", prompt_lower)

        if last_n:
            result["last_n_months"] = int(last_n.group(1))
        elif next_n:
            result["next_n_months"] = int(next_n.group(1))
            result["is_future"] = True
        else:
            result["date"] = self._parse_month_year(prompt_lower)
            if result["date"]:
                dt = datetime.strptime(result["date"], "%d/%m/%Y")
                if dt > self.current_date:
                    result["is_future"] = True

        metric_names = self.metrics_metadata['metric_name'].unique()

        result["metric"] = self._extract_from_prompt(prompt_lower, "metric_name", metric_names)
        result["level"] = self._extract_from_prompt(prompt_lower, "level", self.metrics_metadata['level'].unique())
        result["view"] = self._extract_from_prompt(prompt_lower, "view", self.metrics_metadata['view'].unique())

        if result["metric"] and (result["level"] is None or result["view"] is None):
            mdata = self.metrics_metadata[
                (self.metrics_metadata['metric_name'] == result["metric"])]
            if not mdata.empty:
                if result["level"] is None:
                    result["level"] = mdata.iloc[0]["level"]
                if result["view"] is None:
                    result["view"] = mdata.iloc[0]["view"]

        if not result["metric"] or not result["level"] or not result["view"]:
            return None
        if not result["last_n_months"] and not result["date"] and not result["next_n_months"]:
            return None
        return result

    def _get_historical_data(self, metric: str, level: str, view: str) -> pd.DataFrame:
        return self.time_series_data[
            (self.time_series_data['metric_name'] == metric) &
            (self.time_series_data['level'] == level) &
            (self.time_series_data['view'] == view)
        ].sort_values("date")

    def _forecast_with_theta(self, historical: pd.DataFrame, forecast_date: Optional[str], steps: Optional[int] = None) -> Dict:
        try:
            ts = historical.set_index("date")["value"]
            model = ThetaModel(ts)
            res = model.fit()
            last_date = ts.index[-1]
            if steps is None:
                target = datetime.strptime(forecast_date, "%d/%m/%Y")
                steps = (target.year - last_date.year) * 12 + target.month - last_date.month
                if steps <= 0:
                    return {"value": "PREDICTION_ERROR", "error": "Target date must be in future"}
            forecast = res.forecast(steps=steps)
            if forecast_date:
                return {
                    "value": round(forecast.iloc[-1]),
                    "model_params": str(res.params),
                    "last_historical_date": last_date.strftime("%d/%m/%Y"),
                    "last_historical_value": ts.iloc[-1]
                }
            return {
                "values": [round(v) for v in forecast],
                "model_params": str(res.params),
                "last_historical_date": last_date.strftime("%d/%m/%Y"),
                "last_historical_value": ts.iloc[-1]
            }
        except Exception as e:
            return {"value": "PREDICTION_ERROR", "error": str(e)}

    def get_metric_data(self, info: Dict) -> pd.DataFrame:
        historical = self._get_historical_data(info["metric"], info["level"], info["view"])
        if historical.empty:
            return pd.DataFrame({"error": ["No historical data found."]})

        if info["last_n_months"]:
            start = self.current_date - timedelta(days=30 * info["last_n_months"])
            result = historical[(historical["date"] >= start) & (historical["date"] <= self.current_date)]
            return result[["metric_name", "level", "view", "date", "value"]]

        if info["is_future"] and info["next_n_months"]:
            forecast = self._forecast_with_theta(historical, None, steps=info["next_n_months"])
            base_date = self.current_date + timedelta(days=30)
            result = []
            for i, val in enumerate(forecast["values"]):
                date = (base_date + timedelta(days=30 * i)).replace(day=1)
                result.append({
                    "metric_name": info["metric"],
                    "level": info["level"],
                    "view": info["view"],
                    "date": date.strftime("%d/%m/%Y"),
                    "value": val,
                    "model_params": forecast.get("model_params", ""),
                    "last_historical_date": forecast.get("last_historical_date", ""),
                    "last_historical_value": forecast.get("last_historical_value", "")
                })
            return pd.DataFrame(result)

        if info["is_future"] and info["date"]:
            forecast = self._forecast_with_theta(historical, info["date"])
            return pd.DataFrame([{
                "metric_name": info["metric"],
                "level": info["level"],
                "view": info["view"],
                "date": info["date"],
                "value": forecast["value"],
                "model_params": forecast.get("model_params", ""),
                "last_historical_date": forecast.get("last_historical_date", ""),
                "last_historical_value": forecast.get("last_historical_value", "")
            }])

        date_obj = datetime.strptime(info["date"], "%d/%m/%Y")
        result = historical[historical["date"] == date_obj]
        return result[["metric_name", "level", "view", "date", "value"]]


# ---------------- Example Usage ----------------

processor = MetricDataProcessor()
test_prompts = [
    "Show sales_volume at national level for hr view in march 2024",
    "Display customer_count data for regional cio view on jan 2025",
    "What will be the inventory for product hr view in dec 2025?",
    "Show me last 10 months data for customer_count cio view regional level",
    "Revenue for store view in 05/2024",
    "Give me revenue cso data for Feb'24",
    "Predict sales_volume for national hr view in June 2025",
    "Forecast revenue for product hr view in December 2026",
    "Predict the customer_count regional level cio view for next 5 months"
]

for prompt in test_prompts:
    print(f"\nüìå Prompt: {prompt}")
    extracted = processor.extract_metric_info(prompt)
    if extracted:
        print("üîç Extracted:", {k: v for k, v in extracted.items() if v})
        df = processor.get_metric_data(extracted)
        print(df.to_string(index=False))
    else:
        print("‚ùå Could not extract required information.")

import streamlit as st
from gtts import gTTS
import tempfile
import os
import speech_recognition as sr
import uuid
import win32com.client
from win32com.client import constants
import pythoncom
import re
from ctransformers import AutoModelForCausalLM
from statsmodels.tsa.forecasting.theta import ThetaModel
import pyodbc
from datetime import datetime
from dateutil.relativedelta import relativedelta
import pandas as pd
import numpy as np

# Database connection
conn = pyodbc.connect(
    "DRIVER={ODBC Driver 17 for SQL Server};"
    "SERVER=GBRDSMSQ5000035\\FUS_SQLVIRT_Dev;"
    "DATABASE=FUSION_MI_DEV;"
    "Trusted_Connection=yes;"
)

# Load LLM model
model = AutoModelForCausalLM.from_pretrained(
    "llm1/tinyllama-1.1b-chat-v1.0.Q6_K.gguf",
    model_type="llama"
)

# Initialize session state
if "messages" not in st.session_state:
    st.session_state.messages = []

# Helper functions
def save_speech_to_wav(text, filename):
    pythoncom.CoInitialize()
    speaker = win32com.client.Dispatch("SAPI.SpVoice")
    stream = win32com.client.Dispatch("SAPI.SpFileStream")
    stream.Open(filename, 3)
    speaker.AudioOutputStream = stream
    speaker.Speak(text)
    stream.Close()

def run_forecast(metric, level, view, steps):
    query = """
        SELECT ReportingDate, MetricValue 
        FROM metricpredictmodel 
        WHERE MetricValue is not null 
        AND MetricName=? AND ReportinView=? AND ReportingLevel=?
    """
    df = pd.read_sql(query, conn, params=[metric, level, view])
    if df.empty:
        return None, "no data found"
    df['ReportingDate'] = pd.to_datetime(df['ReportingDate'])
    df['MetricValue'] = df['MetricValue'].str.replace(r'%', '', regex=False).astype(float)
    df.dropna(inplace=True)
    df = df.sort_values('ReportingDate')
    df.set_index('ReportingDate', inplace=True)
    train = df['MetricValue']
    fit_model = ThetaModel(train, period=1).fit()
    steps = int(steps)
    forecast = fit_model.forecast(steps=steps)
    forecast = np.clip(forecast, 0, 100)
    last_date = df.index[-1]
    future_dates = [last_date + relativedelta(months=+1) for _ in range(steps)]
    forecast_df = pd.DataFrame({'Date': future_dates, 'ForecastedValue': forecast.round(2)})
    return forecast_df, None

def get_metric_info():
    query = "SELECT DISTINCT MetricName, MetricID, ReportingLevel, ReportinView FROM metricpredictmodel"
    df = pd.read_sql(query, conn)
    return df

def extract_forecast_period(text):
    # Look for patterns like "next 5 months" or "for 3 months"
    matches = re.findall(r'(?:next|for)\s+(\d+)\s+months?', text, re.IGNORECASE)
    return int(matches[0]) if matches else 6  # default to 6 months if not specified

def extract_date(text):
    # Look for month-year patterns like "January 2024" or "jan 2025"
    month_pattern = r'(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+\d{4}'
    matches = re.findall(month_pattern, text, re.IGNORECASE)
    if matches:
        try:
            return datetime.strptime(matches[0], '%B %Y')
        except:
            try:
                return datetime.strptime(matches[0], '%b %Y')
            except:
                return None
    return None

def process_user_query(input_text):
    input_text = input_text.lower()
    metric_info = get_metric_info()
    
    # Check if query contains metric information
    found_metric = None
    found_level = None
    found_view = None
    
    # First try to match by MetricName
    for _, row in metric_info.iterrows():
        if row['MetricName'].lower() in input_text and row['ReportingLevel'].lower() in input_text and row['ReportinView'].lower()in input_text:
            found_metric = row['MetricName']
            found_level = row['ReportingLevel']
            found_view = row['ReportinView']
            break
    
    # If not found by name, try by ID
    if not found_metric:
        for _, row in metric_info.iterrows():
            if str(row['MetricID']).lower() in input_text and row['ReportingLevel'].lower() in input_text and row['ReportinView'].lower()in input_text:
                found_metric = row['MetricName']
                found_level = row['ReportingLevel']
                found_view = row['ReportinView']
                break
    
    if found_metric:
        query_date = extract_date(input_text)
        forecast_period = extract_forecast_period(input_text)
        
        if query_date:
            # Check if date is after May 2025 (needs forecast)
            if query_date > datetime(2025, 5, 1):
                forecast_df, error = run_forecast(found_metric, found_level, found_view, forecast_period)
                if error:
                    return f"Error: {error}"
                else:
                    return f"Forecast for {found_metric} ({found_level}, {found_view}):\n" + forecast_df.to_string(index=False)
            else:
                # Fetch historical data
                query = """
                    SELECT ReportingDate, MetricValue 
                    FROM metricpredictmodel 
                    WHERE MetricName=? AND ReportingLevel=? AND ReportinView=?
                    AND ReportingDate BETWEEN ? AND ?
                """
                end_date = query_date + relativedelta(months=+forecast_period)
                df = pd.read_sql(query, conn, params=[found_metric, found_level, found_view, query_date, end_date])
                if df.empty:
                    return f"No data found for {found_metric} between {query_date.strftime('%B %Y')} and {end_date.strftime('%B %Y')}"
                return f"Historical data for {found_metric} ({found_level}, {found_view}):\n" + df.to_string(index=False)
    
    # If no metric found or incomplete information, use LLM for general response
    prompt = f"""Q: answer shortly (max limit 25 words). you are an AI assistant called bob. your work is to answer.\n\nQ: {input_text}\nA:"""
    response = model(prompt)
    return response.strip()

# UI Setup
st.title("AI Assistant")

# Display chat history
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Text input
input_text = st.chat_input("What's up?")
if input_text:
    # Process user input
    response = process_user_query(input_text)
    
    # Generate speech and display
    temp_filename = os.path.join(tempfile.gettempdir(), f"{uuid.uuid4()}.wav")
    save_speech_to_wav(response, temp_filename)
    st.audio(temp_filename, format="audio/wav")
    
    # Update chat history
    with st.chat_message("user"):
        st.markdown(input_text)
    st.session_state.messages.append({"role": "user", "content": input_text})
    
    with st.chat_message("assistant"):
        st.markdown(response)
    st.session_state.messages.append({"role": "assistant", "content": response})

# Voice input
if st.button("Start recording"):
    r = sr.Recognizer()
    with sr.Microphone() as source:
        st.write("Speak now...")
        audio_data = r.listen(source)
    try:
        input_text = r.recognize_google(audio_data)
        if input_text:
            response = process_user_query(input_text)
            
            temp_filename = os.path.join(tempfile.gettempdir(), f"{uuid.uuid4()}.wav")
            save_speech_to_wav(response, temp_filename)
            st.audio(temp_filename, format="audio/wav")
            
            with st.chat_message("user"):
                st.markdown(input_text)
            st.session_state.messages.append({"role": "user", "content": input_text})

            with st.chat_message("assistant"):
                st.markdown(response)
            st.session_state.messages.append({"role": "assistant", "content": response})
            
    except sr.UnknownValueError:
        st.write("Sorry, could not understand")
    except sr.RequestError as e:
        st.write(f"Could not request results; {e}")


import seaborn as sns
from sklearn.metrics import mean_absolute_error, r2_score

# Step 1: Create full lag matrix
def create_full_lag_feature_matrix(series: pd.Series) -> pd.DataFrame:
    data = []
    targets = []
    dates = []
    for i in range(1, len(series)):
        input_series = series.iloc[:i]
        target = series.iloc[i]
        features = input_series.values[::-1]  # most recent first
        feature_names = input_series.index[::-1].strftime('%Y-%m-%d')
        row = pd.Series(features, index=feature_names)
        data.append(row)
        targets.append(target)
        dates.append(series.index[i])
    return pd.DataFrame(data), pd.Series(targets, index=dates)

X_full, y_full = create_full_lag_feature_matrix(train)
X_full = X_full.fillna(0)

# Step 2: Walk-forward train surrogate
in_sample_preds = []
for i in tqdm(range(1, len(train))):
    y_subset = train.iloc[:i]
    m = ThetaModel(y_subset, period=1)
    fit = m.fit()
    pred = fit.forecast(steps=1).iloc[0]
    in_sample_preds.append(pred)

X_aligned = X_full.iloc[:len(in_sample_preds)]
surrogate_model = LGBMRegressor()
surrogate_model.fit(X_aligned, in_sample_preds)

# Step 3: Create input for SHAP explanation
latest_input_vector = pd.Series(train.values[::-1], index=train.index[::-1].strftime('%Y-%m-%d')).to_frame().T
latest_input_vector = latest_input_vector.reindex(columns=X_aligned.columns, fill_value=0)

explainer = shap.Explainer(surrogate_model)
shap_values = explainer(latest_input_vector)

# Step 4: Create SHAP DataFrame
shap_df = pd.DataFrame({
    'Date': latest_input_vector.columns,
    'Value': latest_input_vector.values.flatten(),
    'SHAP Value': shap_values.values[0],
})
shap_df['|SHAP|'] = shap_df['SHAP Value'].abs()
top_shap = shap_df.sort_values('|SHAP|', ascending=False).head(10)

# Step 5: Show in Streamlit
st.subheader("üìä SHAP Analysis by Historical Date (Theta Forecast)")
st.dataframe(top_shap[['Date', 'Value', 'SHAP Value']])

fig, ax = plt.subplots(figsize=(10, 5))
sns.barplot(data=top_shap, x='Date', y='SHAP Value', palette='coolwarm', ax=ax)
plt.xticks(rotation=45)
plt.title("Top 10 Influential Dates on Theta Forecast (SHAP)")
plt.tight_layout()
st.pyplot(fig)

    from sklearn.linear_model import LinearRegression
    from dateutil.relativedelta import relativedelta
    import matplotlib.pyplot as plt

    y = train  # Original series
    steps = steps

    t = np.arange(len(y)).reshape(-1, 1)
    trend_model = LinearRegression().fit(t, y.values)

    trend_values = []
    ses_values = []
    final_forecast = []

    for h in range(1, steps + 1):
        t_next = np.array([[len(y) + h - 1]])
        trend = trend_model.predict(t_next)[0]
        theta_pred = forecast.iloc[h - 1]
        ses = 2 * theta_pred - trend

        trend_values.append(trend)
        ses_values.append(ses)
        final_forecast.append(theta_pred)

    last_date = y.index[-1]
    future_dates = [last_date + relativedelta(months=i+1) for i in range(steps)]

    # Optional: Show plot in Streamlit
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(future_dates, trend_values, label='Trend (Œ∏=0)', marker='o', color='blue')
    ax.plot(future_dates, ses_values, label='SES Component (Œ∏=2)', marker='o', color='green')
    ax.plot(future_dates, final_forecast, label='Final Theta Forecast', marker='o', color='red')
    ax.set_title("Theta Model Forecast Decomposition (Next 5 Months)")
    ax.set_xlabel("Date")
    ax.set_ylabel("Forecasted Percentage")
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)
def create_lag_features(series, window=5):
    df_lag = pd.DataFrame()
    for i in range(1, window + 1):
        df_lag[f'lag_{i}'] = series.shift(i)
    df_lag['target'] = series
    return df_lag.dropna()

lag_window = 5
df_lagged = create_lag_features(train, window=lag_window)
X = df_lagged.drop(columns='target')

# Walk-forward predictions using Theta
from lightgbm import LGBMRegressor
from tqdm import tqdm
from sklearn.metrics import mean_absolute_error, r2_score
import shap

in_sample_preds = []
for i in tqdm(range(lag_window, len(train))):
    y_subset = train.iloc[:i]
    m = ThetaModel(y_subset, period=1)
    fit = m.fit()
    pred = fit.forecast(steps=1).iloc[0]
    in_sample_preds.append(pred)

X = X.iloc[:len(in_sample_preds)]  # Align size
surrogate_model = LGBMRegressor()
surrogate_model.fit(X, in_sample_preds)

# STEP 2: SHAP Explanation for Forecasted Point
latest_lags = train.iloc[-lag_window:].values[::-1]
latest_input = pd.DataFrame([latest_lags], columns=[f'lag_{i}' for i in range(1, lag_window + 1)])

explainer = shap.Explainer(surrogate_model)
shap_values = explainer(latest_input)

surrogate_pred = surrogate_model.predict(latest_input)[0]
base_val = shap_values.base_values[0]

explain_df = pd.DataFrame({
    'Lag Feature': latest_input.columns,
    'Lag Value': latest_input.values.flatten(),
    'SHAP Value': shap_values.values[0],
    'Contribution': latest_input.values.flatten() * shap_values.values[0]
})

# Accuracy vs Theta (in-sample)
mae = mean_absolute_error(in_sample_preds, surrogate_model.predict(X))
r2 = r2_score(in_sample_preds, surrogate_model.predict(X))

# STREAMLIT OUTPUT
st.subheader("üîç Surrogate SHAP Explanation (Theta Forecast Driver)")
st.markdown(f"**Surrogate Model Prediction (mimicking Theta):** {surrogate_pred:.2f}")
st.markdown(f"**SHAP Base Value:** {base_val:.2f}")
st.markdown(f"**MAE vs Theta:** {mae:.2f} &nbsp;&nbsp;&nbsp; **R¬≤ Score:** {r2:.3f}")
st.dataframe(explain_df)

# Plots
st.subheader("üìâ SHAP Visuals")
shap.plots.waterfall(shap_values[0], max_display=lag_window, show=False)
st.pyplot(bbox_inches='tight')

shap.plots.beeswarm(shap_values, show=False)
st.pyplot(bbox_inches='tight')

# app.py
import streamlit as st
import subprocess
import os
import signal
import psutil

st.title("üñ±Ô∏è Eye-Controlled Mouse Launcher")

# Track process PID across reruns
if "eye_proc" not in st.session_state:
    st.session_state.eye_proc = None

def is_process_running():
    if st.session_state.eye_proc and psutil.pid_exists(st.session_state.eye_proc.pid):
        return True
    return False

if st.button("‚ñ∂Ô∏è Start Eye Control") and not is_process_running():
    st.session_state.eye_proc = subprocess.Popen(["python", "eye_mouse.py"])
    st.success("Eye Control Started")

if st.button("üõë Stop Eye Control") and is_process_running():
    proc = psutil.Process(st.session_state.eye_proc.pid)
    for child in proc.children(recursive=True):
        child.terminate()
    proc.terminate()
    st.session_state.eye_proc = None
    st.warning("Eye Control Stopped")

if is_process_running():
    st.markdown("üü¢ **Status:** Eye Control is running")
else:
    st.markdown("üî¥ **Status:** Not running")

from llama_cpp import Llama

# Load the TinyLlama GGUF model
llm = Llama(
    model_path="./models/tinyllama/tinyllama-1.1b-chat-v1.0.Q6_K.gguf",
    n_ctx=512,             # context window
    n_threads=4,           # adjust to your CPU
    n_batch=128,           # token batch size
    use_mlock=True         # optional: lock model in memory
)

# Prompt (chat-style)
prompt = """<|system|>
You are a helpful assistant.
<|user|>
What is the capital of France?
<|assistant|>"""

# Generate
output = llm(prompt, max_tokens=100, temperature=0.7, top_p=0.9)

# Print result
print(output['choices'][0]['text'].strip())



# eye_mouse.py
import cv2
import mediapipe as mp
import pyautogui
import time

cam = cv2.VideoCapture(0)
face_mesh = mp.solutions.face_mesh.FaceMesh(refine_landmarks=True)
screen_w, screen_h = pyautogui.size()

while True:
    success, frame = cam.read()
    if not success:
        break

    frame = cv2.flip(frame, 1)
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    output = face_mesh.process(rgb_frame)
    landmark_points = output.multi_face_landmarks
    frame_h, frame_w, _ = frame.shape

    if landmark_points:
        landmarks = landmark_points[0].landmark
        for id, landmark in enumerate(landmarks[474:478]):
            if id == 1:
                screen_x = screen_w * landmark.x
                screen_y = screen_h * landmark.y
                pyautogui.moveTo(screen_x, screen_y)
        left = [landmarks[145], landmarks[159]]
        if (left[0].y - left[1].y) < 0.004:
            pyautogui.click()
            time.sleep(1)

    cv2.imshow('Eye Controlled Mouse', frame)
    if cv2.waitKey(1) == 27:  # ESC key to exit
        break

cam.release()
cv2.destroyAllWindows()

